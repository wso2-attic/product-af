<%
/*
 * Copyright (c) 2014, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
 *
 *   WSO2 Inc. licenses this file to you under the Apache License,
 *   Version 2.0 (the "License"); you may not use this file except
 *   in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing,
 *   software distributed under the License is distributed on an
 *   "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *   KIND, either express or implied.  See the License for the
 *   specific language governing permissions and limitations
 *   under the License.
 */
//TODO: check what is getAppVersionsInStages and getAppVersionsInStage
    include("/jagg/jagg.jag");
    include("/jagg/constants.jag");
    include("/jagg/config_reader.jag");

	var log = new Log("module/application/get/list.jag");

    var modManager = jagg.module("manager");
     //var modResource = jagg.module("resource");
    var modApplication = jagg.module("application");
    var modLifecycle = jagg.module("lifecycle");
    var carbon = require('carbon');
    var server = carbon.server;
    var appfactory = require('appFactory');
    var multitenancy = carbon.multitenancy;
    var modMananger = jagg.module("manager");
    var ApplicationsOfUserCache = Packages.org.wso2.carbon.appfactory.core.cache.ApplicationsOfUserCache;
    var MultiTenantUtils = Packages.org.wso2.carbon.utils.multitenancy.MultitenantUtils;


    var VersionComparator = function(a, b)
    {
        return b.version.localeCompare(a.version);
    };


    var loadConfigValueFromCarbon = function(configElem)
    {
    	return server.osgiService('org.wso2.carbon.base.api.ServerConfigurationService').getFirstProperty(configElem);
    };

    // In index.jag page this method is called before rendering. via getAllAppsOfUser()
    // So untill we fix it from there dont remove start tenantflow here.
    var getAllApps = function(userName){
        var appsOfUser;
        var tenantDomain=modManager.getTenantDomain();
        try{
           var service = server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationInfoService') ;
           appsOfUser = service.getApplicationSummaryForUser(userName);
        } catch (e) {
           log.error("Error while getting list of all applications of the user : " + userName + " of tenant "
                     + "domain : " + tenantDomain);
           log.error(e);
           throw e;
        }
        return appsOfUser;
    };

/**
 *
 * @param userName user name eg:user@tenant.com
 * @returns {*} an array of applications.
 */
    var getApplicationsCreatedByUser = function (userName) {
        var appsCreatedByUser;
        var tenantDomain = modManager.getTenantDomain();
        try {
            var service = server
                    .osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationInfoService');
            appsCreatedByUser = service.getApplicationsCreatedByUser(userName);
            var obj = stringify(appsCreatedByUser)
        } catch (e) {
            log.error("Error while getting all applications created by user : " + userName + " of tenant domain : "
                      + tenantDomain);
            log.error(e);
            throw e;
        }
        return obj;
    };

    var getRepoURL = function(applicationKey, version, auth, isForked)
    {

        if (auth) {
            jagg.module("permission").checkUserActionPermission(applicationKey, PERMISSION_APPLICATION_MEMBER);
        }

        var url;
        var tenantDomain=modManager.getTenantDomain() ;
        try{
            url = server.osgiService('org.wso2.carbon.appfactory.repository.mgt.service.RepositoryManagementService').
                    getURLForAppVersion(applicationKey, version, jagg.getUser().split('@')[0], isForked);

        } catch (e) {
            log.error("Error while getting RepoURL for the application : " + applicationKey + " with version : "
                      + version + " of tenant domain : " + tenantDomain);
            log.error(e);
            throw e;
        }
        return url;
    };

    var getAllAppsCountOfUser = function(userName)
    {
         jagg.module("permission").checkUserAuthenticated();

         // this security check is needed in case of user trying to retrieve all apps of other users.
         if (userName != jagg.getUser()) {
             var message = jagg.getUser() + ' is trying to list applications of user:' + userName;
             log.error(message);
             throw message;
         }
         try {
             var result = getAllApps(userName);
             var ns = new Namespace("http://service.mgt.application.appfactory.carbon.wso2.org");
             var elements = result.ns::["return"].text();
             return elements.length();
         } catch (e) {
             log.error("Error while getting count of all applications of user : " + userName);
             log.error(e);
             throw e;
         }
    };

    var getAllAppsOfUser = function(userName){
        // jagg.module("permission").checkUserAuthenticated();
        var tenantDomain=modManager.getTenantDomain();
         try {
             var result;
             result = getAllApps(userName.split('@')[0]);
             var elementsArray = new Array();
             for (var applicationKey in result){
                 var appInfo = convertAppInfo(result[applicationKey]);
                 if (appInfo != null) {
                     elementsArray.push(appInfo);
                     modMananger.cacheApplicationInfo(tenantDomain, appInfo.key , APPLICATION_INFO_APP_TYPE, appInfo.type);
                 }
             }
             return stringify(elementsArray);
         } catch (e) {
             log.error("Error while getting all application of user : " + userName + " of tenant domain : "
                       + tenantDomain);
             log.error(e);
             throw e;
         }
    };

    var getAppInfo = function (applicationKey) {

        // ################################################################################################
        // ################################################################################################
        // ################################################################################################
        // ################################################################################################
        // ################################################################################################
        // ################################################################################################

        /*

            create constant
            seesion get the value
            if it is null
            creat it and session put
        */
        /*
        session.put("aabbcc","Hasitha");
        var rrrrr = session.get("aabbcc");
        log.info("RRRRRRRR  " + rrrrr);

        var applicationsIconList = session.get("APPLICATIONS_ICON_LIST");
        if(applicationsIconList == null){
            server.osgiService('org.wso2.carbon.appfactory.core.apptype.ApplicationTypeManager').getApplicationTypeBean();
            var obj[applicationKey] = "";
        }
        */

        var result;
        var tenantDomain=modManager.getTenantDomain();

        try {
            result = server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationInfoService')
                    .getApplication(applicationKey);
        } catch (e) {
            log.error(" Error while getting application info for the application : " + applicationKey
                      + " of tenant domain : " + tenantDomain);
            log.error(e);
            throw e;
        }


        if (result != null) {

            var applicationsIconList = session.get("APPLICATIONS_ICON_LIST");
            if(applicationsIconList == null){

            }



            var application = convertAppInfo(result);
            //log.info("\n\n" + stringify(application)+ "\n\n");
            //log.info("Application type =>  " + application.type);

            // add icon this to application here!!!!!
            return application;

        }
        return null;
    };

    var convertAppInfo =  function(resourceContent){
        var application = extractAppInfo(resourceContent,false);
        application.users=modApplication.getUsersOfApplication(resourceContent.id);

        var applicationTypeManager = Packages.org.wso2.carbon.appfactory.core.apptype.ApplicationTypeManager.getInstance();
        var applicationTypeBean = applicationTypeManager.getApplicationTypeBean(application.type);
        application["iconColorClass"] = applicationTypeBean.getIconColorClass();
        application["iconImageClass"] = applicationTypeBean.getIconImageClass();

        session.put("APP_INFO",application);

        //log.info("\n\n User home cache --- \n" + stringify(session.get(USER_HOME_CAHCE)) + "\n");
        return application;
    }

    /*This is a light weight method and it is used only in getUserHomeInfo*/
    var convertAppInfoLightWeight =  function(resourceContent){
        var application = extractAppInfo(resourceContent,true);
        return application;
    }

    var extractAppInfo=function(resourceContent,forUserHome){
        var application={};
        if(forUserHome){
            application.key = resourceContent.id;
            application.type = resourceContent.type;
        }else{
            application.key = resourceContent.id;
            application.owner = resourceContent.owner;
            application.type = resourceContent.type;
            application.language = modManager.getApplicationTypeBean(application.type).getProperty("Language");

            // custom url
            application.mappedSubDomain = resourceContent.mappedSubDomain;
            application.customUrl=resourceContent.customUrl;
            application.customUrlVerificationCode = resourceContent.customUrlVerificationCode;

            application.description = resourceContent.description;
            application.repositoryType = resourceContent.repositoryType;
            application.repositoryTypeDisplayName = getProperty("RepositoryProviderConfig." + application.repositoryType + ".Property.DisplayName");
            application.branchCount=resourceContent.branchCount;
        }

        application.typeDisplayName = modManager.getApplicationTypeBean(application.type).getDisplayName();
        application.isUploadable = modManager.getApplicationTypeBean(application.type).isUploadableAppType();
	    application.name = resourceContent.name;
        application.repoAccessability = resourceContent.repoAccessability;
        application.appTypeIcon = modManager.getApplicationTypeBean(application.type).getIconImageClass();


        //TODO
        application.inProduction = false;
        return application;
    };

    // This funciton get application rxt from registry and populate application object.
    // This is not secured as this is calling from getAllApp method. Any caller of this
    // function need to secure acess. Permission check is removed do reduce the tenant loading.
    /* var getAppInfoWithoutUserRoles = function(applicationKey)
    {
        var path = APPLICATIONS + applicationKey + APP_INFO;
        if (modResource.resourceExists(path)) {
            var resource = modResource.getResource(path);
            var resourceContent = resource.content;

            if (resourceContent. *::application. *::key.text() != undefined){
                var application = {};
                application.key = resourceContent. *::application. *::key.text();
                application.name = resourceContent. *::application. *::name.text();
                application.description = resourceContent. *::application. *::description.text();
                application.type = resourceContent. *::application. *::type.text();
                application.repositoryType = resourceContent. *::application. *::repository. *::type.text();
                return application;
            }
        }
        return null;
    }
    ;*/

    //checked
    var getAllAppVersionsInStage = function(stageName, userName)
    {
        var visibilityPermissionToStage = PERMISSION_VISIBILITY_STAGE + stageName;

        var allAppVersionArray = new Array();
        var applicationList = session.get(APPLICATION_LIST_CACHE);
        if(applicationList == null) {
            applicationList = mod.getAllAppsOfUser(jagg.getUser());
           session.put(APPLICATION_LIST_CACHE, applicationList);
        }
        var parsedArray = parse(applicationList);

        for (var i = 0; i < parsedArray.length; i++) {
            var application = parsedArray[i];
            var applicationKey = application.key;
            if (jagg.module("permission").isUserAccessGranted(applicationKey, visibilityPermissionToStage)) {
                var appVersions = getAppVersionsInStage(stageName, applicationKey, userName);
                if (appVersions != null) {
                    allAppVersionArray = allAppVersionArray.concat(appVersions);
                }
            }
        }
        return stringify(allAppVersionArray);
    };


    var getDeployedBuildId = function(applicationKey, version, stage){
    	return 1;
    };

    //Read the application build status
    var getLatestBuildSuccessInfo = function(applicationKey, version, stageName)
    {
        var applicatoinPath = APPLICATIONS + applicationKey;
        var path = applicatoinPath + "/" + stageName + "/" + version + "/appversion";
        var ret = {};
        ret.buildinfo = getLastBuildStatus(path);
        return ret;
    };

    var getAppVersionsInStage = function(stageName, applicationKey, userName, metaDataNeed, buildableforstage, isRoleBasedPermissionAllowed)
    {
        jagg.module("permission").checkUserActionPermission(applicationKey, PERMISSION_APPLICATION_MEMBER);
        if (isRoleBasedPermissionAllowed == "true") {
            var hasPermissiontToStage = jagg.module("permission").hasPermissionToStage(applicationKey, stageName);
            if (!hasPermissiontToStage) {
                return null;
            }
        }
        var artifacts;
        var tenantDomain=modManager.getTenantDomain() ;
        try{
            artifacts = server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationInfoService')
                    .getAllVersionsOfApplication(tenantDomain, applicationKey);
        } catch (e) {
            log.error("Error while getting application versions of : " + applicationKey + " in stage : " + stageName
                      + " of the tenant domain : " + tenantDomain);
            log.error(e);
            throw e;
        }
        var artifactsInStage = new Array();
        var artifactsInStageCount = 0;
        if (artifacts != undefined && artifacts.length > 0) {
            for(index in artifacts) {
                var element = artifacts[index];
                if(element['stage'] == stageName) {
                    artifactsInStage[artifactsInStageCount] = element;
                    artifactsInStageCount++;
                }
            }
        }
        var versions = getVersionInfo(applicationKey, artifactsInStage);
        if(versions !=null) {
            return stringify(versions);
        } else {
            return null;
        }
    }
    ;

    var getBranchInfo= function(applicationKey){
    	var result,tenantDomain=modManager.getTenantDomain();
    	try{
            result = server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationInfoService')
                    .getBasicApplicationInfo(applicationKey);
        } catch (e) {
            log.error(" Error while getting branch info for the application : " + applicationKey
                      + " of tenant domain : " + tenantDomain);
            log.error(e);
            throw e;
    	}
    	return result;
    }

   /*this mehtod return the information to populate the user home
   * of the user logged in user
   * */
    var getUserHomeInfo= function(){
        var userName=modManager.getDomainlessUserName();
    	var result,tenantDomain=modManager.getTenantDomain();
    	try{
            result = server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationInfoService')
                    .getApplicationSummaryForUser(userName);

    		 var elementsArray = new Array();
             for (var applicationKey in result){
                 log.info("$$$$$$$$$applicationKey:  " + applicationKey)
                 var appInfo = convertAppInfoLightWeight(result[applicationKey]);
                 if (appInfo != null) {
                     elementsArray.push(appInfo);
                 }
             }
             return elementsArray;
         } catch (e) {
            log.error("Error while getting the user home info for the user : " + userName + " of tenant domain : "
                      + tenantDomain);
            log.error(e);
            throw e;
    	}
    	return result;
    }

    /**
     * Get deleted app keys of the tenantDomain from application context.
     *
     * @returns Array of deleted keys of the user's tenantDomain
     */
    var getDeletedAppKeysFromAppContext = function(){
        var allDeletedAppKeys = application.get(APP_CTX_DELETED_KEYS);
        var tenantDomain=modManager.getTenantDomain();
        var deletedAppKeysOfTenant = new Array();
        if(!isEmpty(allDeletedAppKeys) && allDeletedAppKeys[tenantDomain] &&
                             allDeletedAppKeys[tenantDomain].length > 0) {
            deletedAppKeysOfTenant = allDeletedAppKeys[tenantDomain];
        }
        return deletedAppKeysOfTenant;
    };


    /**
     * Get updated user user home information from cache.
     *
     * @returns  application info list as below
     * {
     *      "COMPLETED":{
     *              appKey1:{//app info},
     *              ...
     *          },
     *      "PENDING":{
     *              appKey5:{//app info},
     *              ...
     *          },
     *      "FAULTY":{
     *              appKey9:{//app info},
     *              ...
     *          },
     *  }
     */
    var getUpdatedUserHomeData = function(){
        updateUserHomeCacheWithDeletedApps();   // remove the deleted apps from the user home cache
        updateUserHomePendingApps();            // update the application creation status
        return getUserHomeDataFromCache();
    };

    /**
     * Get user home information from cache.
     * If the request is a cache miss, retrieve data from backend and return while caching
     * @returns  application info list as below
     * {
         *      "COMPLETED":{
         *              appKey1:{//app info},
         *              ...
         *          },
         *      "PENDING":{
         *              appKey5:{//app info},
         *              ...
         *          },
         *      "FAULTY":{
         *              appKey9:{//app info},
         *              ...
         *          },
         *  }
     */
    var getUserHomeDataFromCache = function(){
        var userHomeData = session.get(USER_HOME_CAHCE);
	var isApplicationsChanged = isApplicationsOfUserChanged();
        if(!userHomeData || isApplicationsChanged){
            userHomeData = getUserHomeInformation();
            session.put(USER_HOME_CAHCE,userHomeData);
        }
        return userHomeData;
    };

    /**
     * Add an application to user home cache.
     *
     * @param creationStatus application creation status
     * @param appKey application key
     * @param application application object
     */
    var addAppToUserHomeCache = function(creationStatus , appKey, application){
        var userHomeData = getUserHomeDataFromCache();
        userHomeData[creationStatus][appKey] = application;
        session.put(USER_HOME_CAHCE,userHomeData);
    };

    /**
     * Update the user home cache with deleted apps.
     * This method will get the deleted app keys form the application context and remove those apps from the user home
     * cache. We need this step since once an application is deleted, user home should be updated with the existing apps.
     */
    var updateUserHomeCacheWithDeletedApps = function() {
        var deletedKeys = getDeletedAppKeysFromAppContext();
        if(deletedKeys && deletedKeys.length > 0) {
            removeAppsFromUserHomeCache(APPLICATION_CREATION_STATUS.COMPLETED,deletedKeys);
            removeAppsFromUserHomeCache(APPLICATION_CREATION_STATUS.PENDING,deletedKeys);
            removeAppsFromUserHomeCache(APPLICATION_CREATION_STATUS.FAULTY,deletedKeys);
        }
    };

    /**
     * Remove application from user home cache.
     *
     * @param creationStatus current application creation status of the app.
     * @param appKeys application keys to be deleted as an Array
     */
    var removeAppsFromUserHomeCache = function(creationStatus , appKeys){
        var userHomeData = getUserHomeDataFromCache();
        for(var index in appKeys){
            delete userHomeData[creationStatus][appKeys[index]];
        }
        session.put(USER_HOME_CAHCE,userHomeData);
    };

    /**
     * Check and update the pending app status and move to corresponding list of the user home cache.
     */
    var updateUserHomePendingApps = function(){
        var appKeys = getAppKeysFromUserHomeCache(APPLICATION_CREATION_STATUS.PENDING);
        var userHomeData = getUserHomeDataFromCache();
        if (appKeys.length > 0) {
            var updatedStatus = getAppCreationStatusByKeys(appKeys);
            for (var index in appKeys) {
                var appkey = appKeys[index];
                if (!isEmpty(updatedStatus) && updatedStatus[appkey]) {
                    if (APPLICATION_CREATION_STATUS.PENDING != updatedStatus[appkey]) {
                        // remove from pending array and put in correct array either faulty or completed
                        userHomeData = moveApplicationFromCreationStatus(userHomeData, APPLICATION_CREATION_STATUS.PENDING,
                                updatedStatus[appkey], appkey);
                    }
                } else {
                    // check whether it is available in failed application list and move from pending to failed
                    if (isFailedApplication(appkey)) {
                        userHomeData = moveApplicationFromCreationStatus(userHomeData, APPLICATION_CREATION_STATUS.PENDING,
                                APPLICATION_CREATION_STATUS.FAULTY, appkey);
                    }
                }
                session.put(USER_HOME_CAHCE,userHomeData);
            }
        }
    };

    /**
     * Get user home information from backend.
     *
     * @returns  application info list as below
     * {
     *      "COMPLETED":{
     *              appKey1:{//app info},
     *              ...
     *          },
     *      "PENDING":{
     *              appKey5:{//app info},
     *              ...
     *          },
     *      "FAULTY":{
     *              appKey9:{//app info},
     *              ...
     *          },
     *  }
     */
    var getUserHomeInformation= function(){
        var userName=modManager.getDomainlessUserName();
        var context=multitenancy.getPrivilegedCarbonContext();
        var service = getApplicationInfoService(context);
        try{
            var result=service.getApplicationSummaryForUser(userName);

            // init
            var appList = {};
            appList[APPLICATION_CREATION_STATUS.COMPLETED] ={};
            appList[APPLICATION_CREATION_STATUS.PENDING] ={};
            appList[APPLICATION_CREATION_STATUS.FAULTY] ={};

            for (var listKey in result){
                log.info("$$$$$$$$$applicationKey:  " + listKey)
                var appInfo = convertAppInfoLightWeight(result[listKey]);
                if (appInfo != null) {
                    log.info("***************appInfo.applicationCreationStatus: " + appInfo.key)
                    var creationStatus = (appInfo.applicationCreationStatus) ? (appInfo.applicationCreationStatus) :
                                         APPLICATION_CREATION_STATUS.PENDING;
                    appList[creationStatus][appInfo.key] = appInfo;
                }
            }
            return appList;
        } catch (e) {
            log.error("Error while getting user home information for the  user : " + userName);
            log.error(e);
            throw e;
        }
        return result;
    };

    /**
     * Get application keys of application which has {@code creationStatus}.
     *
     * @param creationStatus  APPLICATION_CREATION_STATUS.*
     * @returns {Array} application keys
     */
    var getAppKeysFromUserHomeCache = function(creationStatus){
        var userHomeData = getUserHomeDataFromCache();
        var appKeys = new Array();
        var statusAppList = userHomeData[creationStatus];
        for (var appKey in statusAppList){
            appKeys.push(appKey);
        }
        return appKeys;
    };

    /**
     * Convert given {@code hashMap} to js object
     *
     * @param hashMap HashMap to be converted
     * @param valuesAsStrings whether to convert values to string or not.
     * @returns js Object with key value pairs
     *  e.g {
     *          appkey1:COMPLETED,
     *          appKey2:PENDING
     *      }
     */
    var convertHashMapToJsObject =function(hashMap,valuesAsStrings){
        var jsObject = {};
        if(hashMap && hashMap.entrySet() && hashMap.entrySet().toArray()) {
            var entitySetArray = hashMap.entrySet().toArray();
            for(var index in entitySetArray){
                var entity=entitySetArray[index];
                if(valuesAsStrings == true){
                    jsObject[entity.getKey()] = entity.getValue().toString();
                } else {
                    jsObject[entity.getKey()] = entity.getValue()
                }
            }
        }
        return jsObject;
    };

    /**
     * Get application creation status by application keys.
     * @param  applicationKeys array of application keys
     *
     * @returns js Object with appkey-status as key value pairs
     *  e.g {
     *          appkey1:COMPLETED,
     *          appKey2:PENDING
     *      }
     */
    var getAppCreationStatusByKeys = function(applicationKeys){
        var context=multitenancy.getPrivilegedCarbonContext();
        var service = getApplicationInfoService(context);
        try{
            var resultHashMap = service.getAppCreationStatus(applicationKeys);
            return convertHashMapToJsObject(resultHashMap,true);
        } catch (e) {
            log.error("Error while retrieving app creation status for app keys : " + applicationKeys);
            log.error(e);
            throw e;
        }
    };

    /**
     * Check whether the application is failed or not
     * @param applicationKey application key
     * @returns true if application is failed
     */
    var isFailedApplication = function(applicationKey){
        var context=multitenancy.getPrivilegedCarbonContext();
        var service = getApplicationInfoService(context);
        try{
            return service.isFailedApplication(applicationKey);
        } catch (e) {
            log.error("Error while checking whether the application is failed for app key : " + applicationKey);
            log.error(e);
            throw e;
        }
    };

    /**
     * Get ApplicationInfoService osgi service.
     *
     * @param context Privileged Carbon Context
     * @returns service reference
     */
    var getApplicationInfoService = function(context){
        var tenantDomain=null;
        try{
            tenantDomain=modManager.getTenantDomain() ;
            return server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationInfoService');
        } catch(e) {
            log.error("Error while getting ApplicationInfoService for the tenant : " + tenantDomain);
            log.error(e);
            throw e;
        }
    };

    /**
     * Moves application represented by {@code appKey} from {@code currentStatus} to {@code newStatus}.
     *
     * @param appList user home data object
     * @param currentStatus current status of the app
     * @param newStatus new status of the app
     * @param appKey application key.
     * @returns {*} updated user home object
     */
    var moveApplicationFromCreationStatus = function(appList, currentStatus , newStatus, appKey){
        if(!isEmpty(appList) && !isEmpty(appList[currentStatus]) && !isEmpty(appList[currentStatus][appKey])) {
            if(isEmpty(appList[newStatus])){
                appList[newStatus] = {};
            }
            appList[newStatus][appKey] = appList[currentStatus][appKey];
            appList[newStatus][appKey][FIELD_APP_CREATION_STATUS] = newStatus;
            delete appList[currentStatus][appKey];
        }
        return appList;
    };

    /**
     * Check whether the {@code obj} is empty object({}) or not.
     *
     * @param obj
     * @returns {boolean}
     */
    var isEmpty = function(obj){
        if(!obj){       // if object is null
            return true;
        } else {
            return (Object.getOwnPropertyNames(obj).length === 0);
        }
    };

    var getApplicationInfoService = function () {
        var carbon = require('carbon');
        var service;
        var tenantDomain=modManager.getTenantDomain() ;
        try{
            service = carbon.server
                    .osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationInfoService');
        } catch (e) {
            log.error("Error while getting application info service for the tenant domain : " + tenantDomain);
            log.error(e);
            throw e;
        }
        return service;
    }


   var getMetaDataForApplicationState = function(applicationKey, version, stage, state, type)
    {
        jagg.module("permission").checkUserActionPermission(applicationKey, PERMISSION_APPLICATION_MEMBER);


        var tenantDomain = modManager.getTenantDomain();
        var loggedInUser = jagg.getUser();
        var userName = "";
        if (loggedInUser != null) {
            userName = loggedInUser.split("@")[0];
        }
        var status;
        var url;
        var accessUrl;

        try {
            accessUrl = server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationInfoService')
                    .getApplicationUrl(applicationKey, version, stage, tenantDomain);
            status = server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationInfoService')
                    .getApplicationStatus(applicationKey, version, stage);
            if(!status){
                 //fix for APPFAC-2195
                 //load the tenant
                 if(accessUrl){
                   var xhr = new XMLHttpRequest();
                   xhr.open("GET",accessUrl + "",false);
                   xhr.send("");
                   }
                status = server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationInfoService')
                        .getApplicationStatus(applicationKey, version, stage);
            }
            if(status){
               url=accessUrl;
             }

        } catch (e) {
            log.error(" Error while getting metadata for application state  for the application : " + applicationKey
                      + " with version : " + version + " in stage : " + stage);
            log.error(e);
            throw e;
        }

        var data = {};
        data.url = url;
        data.status = status;
        data.type = type;

        return data;
    };


    var listAppsWithDetails = function()
    {
        // not secured as getAppInfo method is secured.
        var applicationKeyArray = jagg.require(jagg.getModulesDir() + "dashboard/get/list.jag").getAllApplications.apply(this, arguments);
        var applicationsArray = new Array();
        for (var _index = 0; _index < applicationKeyArray.length; _index++) {
            var _application = getAppInfo(applicationKeyArray[_index]);
            applicationsArray[_index] = _application;
        }
        return applicationsArray;
    }
    ;

//chekced
    var getAllStages = function()
    {
        jagg.module("permission").checkUserAuthenticated();
        var stages = getProperties(DEPLOYMENT_STAGES);
        if (stages == null) {
            return null;
        }

        var stageArray = new Array();

        var counter = 0;
        while (stages[counter] != null) {
            stageArray[counter] = stages[counter];
            counter++;
        }

        return stringify(stageArray);
    }
    ;

//chekced
    var getBuildableStages = function()
    {
        jagg.module("permission").checkUserAuthenticated();
        var stages = getProperties(DEPLOYMENT_STAGES);
        if (stages == null) {
            return null;
        }

        var stageArray = new Array();

        var counter = 0;
        try {
            while (stages[counter] != null) {
                if (getProperty('ApplicationDeployment.DeploymentStage.' + stages[counter] + '.Buildable') == "true") {
                    stageArray[stageArray.length] = stages[counter];
                }
                counter++;
            }
        } catch (e) {
            log.error("Error while getting Buildable stages from appfactory.xml");
            log.error(e);
            throw e;
        }

        return stringify(stageArray);
    }
    ;

//chekced
    var getAllAppVersionsInStages = function(userName)
    {
        jagg.module("permission").checkUserAuthenticated();
        var allAppVersionArray = new Array();
        var applicationList = session.get(APPLICATION_LIST_CACHE);
        if(applicationList == null) {
            applicationList = mod.getAllAppsOfUser(userName);
            session.put(APPLICATION_LIST_CACHE, applicationList);
        }
        var allStages = getAllStages();
        var parsedStages = parse(allStages);
        var parsedArray = parse(applicationList);

        for (var i = 0; i < parsedArray.length; i++) {
            var application = parsedArray[i];

            for (var j = 0; j < parsedStages.length; j++) {
                var stage = parsedStages[j];
                var hasPermissiontToStage = jagg.module("permission").hasPermissionToStage(application.key, stage);
                if (!hasPermissiontToStage) {
                    continue;
                }
                var appVersions = getAppVersionsInStage(stage, application.key, userName);
                if (appVersions != null) {
                    allAppVersionArray = allAppVersionArray.concat(appVersions);
                }
            }
        }

        return stringify(allAppVersionArray);
    }
    ;

    var getRetiredVersions = function(applicationKey, userName)
    {
        jagg.module("permission").checkUserActionPermission(applicationKey, PERMISSION_APPLICATION_MEMBER);
        var versionsArray = new Array();
        var retiredApp = getAppVersionsInStage("Retired", applicationKey, userName, false, false, false);
        if (retiredApp != null) {
            retiredApp = parse(retiredApp);
            if (retiredApp.length > 0) {
                var application = retiredApp[0];
                var versions = application.versions;
                for (var j = 0; j < versions.length; j++) {
                    var versionInfo = versions[j];
                    versionsArray.push(versionInfo.version);
                }
            }
        }
        return versionsArray;
    }
    ;

    var getAppVersionInfoByVersion = function(applicationKey, version, userName)
    {

        var artifacts;
        var tenantDomain=modManager.getTenantDomain() ;
        try {
            artifacts = server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationInfoService')
                    .getAllVersionsOfApplication(tenantDomain, applicationKey);
        } catch (e) {
            log.error("Error while getting application version info by version for the applicatin : " + applicationKey
                      + " with version : " + version + " of tenant domain : " + tenantDomain);
            log.error(e);
            throw e;
        }

        var artifactsInStage=[];

	    for(index in artifacts) {
		var element = artifacts[index];
			if(element['version'] == version) {
			    artifactsInStage.push(element);
	            break;
			}
	    }

        var versions = getVersionInfo(applicationKey, artifactsInStage);
        return versions;

    };

    var getAppVersionAllInfoByVersion = function(applicationKey, version, userName) {
        // set the current selected version
        putSelectedVersionToSession(applicationKey, version);

        // generate the app version information
        var result = new Array();
        try {
            var artifacts = server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationInfoService')
                    .getAllVersionsOfApplication(modManager.getTenantDomain(), applicationKey);
            if (artifacts && artifacts.length > 0) {
                var applicationInfo = getAppInfo(applicationKey);
                var versions = new Array();
                if (applicationInfo) {
                    var versionInfo= {};
                    for (var key in artifacts) {
                        var versionData = artifacts[key];
                        versions.push(versionData['version']);
                        if(versionData['version'] == version) {
                            versionInfo = generateAppVersion(applicationKey, versionData);
                        }
                    }
                    applicationInfo.versions = versions;
                    applicationInfo.versionInfo = versionInfo;
                    result = applicationInfo;
                }
            }
        } catch (e) {
            log.error("Error while getting application version all info by version for the applicatin : " + applicationKey
                      + " with version : " + version + " of tenant domain : " + tenantDomain);
            log.error(e);
            throw e;
        }
        return result;
    }

    var putSelectedVersionToSession = function(applicationKey, currentVersion) {
        var selectedVersions = session.get("SELECTED_VERSIONS");
        if(!selectedVersions) {
            selectedVersions = new Array;
            session.put("SELECTED_VERSIONS", selectedVersions);
        }

        var previousVersionData;
        for (var key in selectedVersions) {
            var versionData = selectedVersions[key];
            if (versionData) {
                if(versionData.applicationKey == applicationKey) {
                    previousVersionData = versionData;
                    break;
                }
            }
        }

        if(previousVersionData) {
            previousVersionData.version = currentVersion;
        } else {
            var selectedVersion = {};
            selectedVersion.version = currentVersion;
            selectedVersion.applicationKey = applicationKey;
            selectedVersions.push(selectedVersion);
        }
    }

    var getAppVersionsInStages = function(applicationKey, userName, metaDataNeed, buildableforstage, isRoleBasedPermissionAllowed)
    {
        jagg.module("permission").checkUserActionPermission(applicationKey, PERMISSION_APPLICATION_MEMBER);
        var applicatoinPath = APPLICATIONS + applicationKey;
        var artifacts;
        var tenantDomain=modManager.getTenantDomain() ;
        try {
            artifacts = server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationInfoService')
                    .getAllVersionsOfApplication(modManager.getTenantDomain(), applicationKey);
        } catch (e) {
            log.error("Error while getting app versions in stages for the application : " + applicationKey
                      + " of tenant domain : " + tenantDomain);
            log.error(e);
            throw e;
        }
	    var versions = getVersionInfo(applicationKey, artifacts);
        if(versions !=null) {
            return stringify(versions);
        } else {
            return null;
        }
    };

    var getAppVersionsByStage = function(applicationKey, stage){
        var allResults = getAppVersionsInStages(applicationKey);
        return generateCustomUrlResponse(parse(allResults),stage);
    };

    function generateCustomUrlResponse(allResults, stage){
        var simplifiedAppInfo = {};
        if(allResults.length > 0){
            var appinfo = allResults[0];
            simplifiedAppInfo["key"] = appinfo.key;
            simplifiedAppInfo["type"] = appinfo.type;
            simplifiedAppInfo["mappedSubDomain"] = appinfo.mappedSubDomain;
            simplifiedAppInfo["customUrl"] = appinfo.customUrl;
            simplifiedAppInfo["customUrlVerificationCode"] = appinfo.customUrlVerificationCode;
            simplifiedAppInfo["isUploadable"] = appinfo.isUploadable;
            simplifiedAppInfo["name"] = appinfo.name;
            simplifiedAppInfo["versions"] = getSimplifiedVersionArray(appinfo.versions, stage);
        }
        return simplifiedAppInfo;
    }

    function getSimplifiedVersionArray(versionsArray, stage){
        var simplifiedVersionArray = [];
        for (var i = 0; i < versionsArray.length; i++) {
            var version = versionsArray[i];
            if (0 == version.stage.localeCompare(stage)) {
                simplifiedVersionArray.push(
                        {
                            "version": version.version,
                            "productionMappedDomain": version.productionMappedDomain
                        });
            }
        }
        return simplifiedVersionArray;
    }

var getStage = function(applicationKey, version) {
    jagg.module("permission").checkUserAuthenticated();
    var tenantDomain = modManager.getTenantDomain();
    try {
        return getApplicationInfoService().getStage(applicationKey, version);
    } catch (e) {
        log.error("Error while getting stage of application :  " + applicationKey + " with version : " + version
                  + " of the tenant domain : " + tenantDomain);
        log.error(e);
        throw e;
    }
};

var getVersionInfo = function(applicationKey, artifacts) {
    //send the call to the backend
    if (artifacts != undefined && artifacts.length > 0) {
        var appVersions = new Array();
        var applicationInfo = getAppInfo(applicationKey);
        if (applicationInfo != null && applicationInfo != undefined) {
            var arrVersions = new Array();
            var k = 0;
            for (var i = 0; i < artifacts.length ; i++) {
                var element = artifacts[i];
                arrVersions[k] = generateAppVersion(applicationKey, element);
                k = k + 1;
            }
            arrVersions.sort(VersionComparator);

            //////applicationInfo.stage = stageName + '';
            applicationInfo.versions = arrVersions;
            appVersions[0] = applicationInfo;
        }
        return appVersions;
    }
return null;
};

var generateAppVersion = function(applicationKey, data) {
    var versionInfo = {};
    if(data) {
        versionInfo.version = data['version'];
        versionInfo.autoDeployment = "true";
        versionInfo.stage = data['stage'];
        versionInfo.isAutoBuild = data['autoBuild'] ? "true" : "false" ;
        versionInfo.isAutoDeploy = data['autoDeploy'] ? "true" : "false";
        versionInfo.repoURL = getRepoURL(applicationKey, versionInfo.version, true, false);
        versionInfo.lastBuildResult = data['lastBuildStatus']!=null ? data['lastBuildStatus'] : '';
        versionInfo.currentBuildStatus = data['currentBuildStatus'];
        versionInfo.promoteStatus = data['promoteStatus'];
        versionInfo.deployedBuildId = data['lastDeployedId'];
        versionInfo.productionMappedDomain = data['productionMappedDomain'];
        versionInfo.isInitialStage = modLifecycle.isInitialLifeCycleStage(versionInfo.stage);
    }
    return versionInfo;
}


var getRepoUserInfo = function(applicationKey, artifacts) {
        //send the call to the backend
        if (artifacts != undefined && artifacts.length > 0) {
            var appVersions = new Array();
            var applicationInfo = getAppInfo(applicationKey);
            if (applicationInfo != null && applicationInfo != undefined) {
                var arrVersions = new Array();
                var k = 0;
                for (var i = 0; i < artifacts.length ; i++) {
                    var versionInfo = {};
                    var element =artifacts[i];
                    versionInfo.version = element['version'];
                    versionInfo.autoDeployment = "true";

		            versionInfo.stage = element['stage'];
                    versionInfo.isAutoBuild = element['autoBuild'] ? "true" : "false" ;
                    versionInfo.isAutoDeploy = element['autoDeploy'] ? "true" : "false";
                    versionInfo.repoURL = element['repoURL'];
                    versionInfo.lastBuildResult =element['lastBuildStatus']!=null ? element['lastBuildStatus'] : '';
                    versionInfo.currentBuildStatus =element['currentBuildStatus'];
                    versionInfo.promoteStatus =element['promoteStatus'];
                    versionInfo.deployedBuildId = element['lastDeployedId'];
                    arrVersions[k] = versionInfo;
                    k = k + 1;
                }

                arrVersions.sort(VersionComparator);

                //////applicationInfo.stage = stageName + '';
                applicationInfo.versions = arrVersions;
                appVersions[0] = applicationInfo;
            }
	        return appVersions;
        }
        return null;
};

    var getAppCountInStage = function(applicationKey, userName)
    {
        // no need to secure as internal call is secured.
        var versionArray = new Array();
        var allStages = getAllStages();

        for (var i = 0; i < allStages.length; i++) {
            var stageName = allStages[i];
            var versionEntry = {};
            versionEntry.stage = stageName;
            var applicationList = getAllAppVersionsInStage(stageName, applicationKey, userName);

            if (applicationList == null) {
                continue;
            }

            var versionCount = 0;
            for (var j = 0; j < applicationList.length; j++) {
                var applicationInfo = applicationList[j];

                if (applicationInfo == undefined) {
                    continue;
                }
                log.info("applicationInfo.versions: ***********************" + applicationList.length)
                versionCount += applicationInfo.versions.length;
            }

            versionEntry.count = versionCount;
            versionArray[i] = versionEntry;
        }
        return versionArray;
    };

  //application icon resource read from registry
    var loadAppIcon = function (applicationKey) {
        var tenantDomain = modManager.getTenantDomain();
    	 try{
    	  	var serverUrl = getProperty(APPFACTORY_SERVER_URL);
    	  	var carbon = require('carbon');
    	  	var registryOsgi = new carbon.registry.Registry(serverUrl, {
    	  	   username: getProperty(ADMIN_USERNAME),
    	  	   password: getProperty(ADMIN_PASSWORD)
    	  	});
    	  	var path = "/_system/governance/repository/appicon/icon_"+ applicationKey ;
    	  	var res = registryOsgi.get(path);
    	  	return res;

    	  } catch (e) {
             log.error("Error  while loading the icon for application : " + applicationKey + " of tenant : "
                       + tenantDomain);
             log.error(e);
             throw e;
    	  }
    };

    var getAppVersionsOfUser = function(applicationKey, userName, metaDataNeed, buildableforstage, isRoleBasedPermissionAllowed)
    {
        jagg.module("permission").checkUserActionPermission(applicationKey, PERMISSION_APPLICATION_MEMBER);
        var artifacts;
        var tenantDomain=modManager.getTenantDomain() ;
        try {
            artifacts = server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationInfoService')
                    .getAllVersionsOfApplicationPerUser(modManager.getTenantDomain(), applicationKey, userName);
        } catch (e) {
            log.error("Error while getting application versions of application : " + applicationKey + " for the user : "
                      + userName + " of tenant domain : " + tenantDomain);
            log.error(e);
            throw e;
        }
	    var versions = getRepoUserInfo(applicationKey, artifacts);
        if(versions !=null) {
            return stringify(versions);
        } else {
            return null;
        }
    };
     var getBuildandDelpoyedStatus= function(applicationKey,version){
          var buildAndDeployInfo;;
          var result ={};
      	  var tenantDomain=modManager.getTenantDomain() ;
      	  try{
              buildAndDeployInfo = server
                      .osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationInfoService')
                      .getBuildandDelpoyedStatus(applicationKey, tenantDomain, version);
                 if(buildAndDeployInfo!=null){
                 	result.buildId=buildAndDeployInfo['lastBuildId'];
                 	result.buildStatus=buildAndDeployInfo['lastBuildStatus'];
                 	result.deployedId=buildAndDeployInfo['lastDeployedId'];
                 }
          }catch (e){
              log.error(" Error while getting build and deployed status for application : " + applicationKey
                        + " with version : " + version);
              log.error(e);
              throw e;
      	  }

      	  if(result !=null) {
      	      return stringify(result);
      	  } else {
      	      return null;
      	  }


    };

    var isApplicationsOfUserChanged = function(){
       var tenantDomain=modManager.getTenantDomain();
       try{
           var isApplicationsOfUserChanged = ApplicationsOfUserCache.getApplicationsOfUserCache().isUserInvitedToApplication(MultitenantUtils.getTenantAwareUsername(jagg.getUser()));
       }catch (e){
           var errMsg = "Error  while checking user : " + jagg.getUser() + " added to an application \n" ;
           log.debug( errMsg );
       }
       return isApplicationsOfUserChanged;
    }
%>
