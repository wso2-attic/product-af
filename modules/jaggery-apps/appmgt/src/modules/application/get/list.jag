<%
/*
 * Copyright (c) 2014, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
 *
 *   WSO2 Inc. licenses this file to you under the Apache License,
 *   Version 2.0 (the "License"); you may not use this file except
 *   in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing,
 *   software distributed under the License is distributed on an
 *   "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *   KIND, either express or implied.  See the License for the
 *   specific language governing permissions and limitations
 *   under the License.
 */
//TODO: check what is getAppVersionsInStages and getAppVersionsInStage
    include("/jagg/jagg.jag");
    include("/jagg/constants.jag");
    include("/jagg/config_reader.jag");

	var log = new Log("module/application/get/list.jag");

    var modManager = jagg.module("manager");
     //var modResource = jagg.module("resource");
    var modApplication = jagg.module("application");
    var modLifecycle = jagg.module("lifecycle");
    var carbon = require('carbon');
    var server = carbon.server;
    var appfactory = require('appFactory');
    var multitenancy = carbon.multitenancy;
    var modMananger = jagg.module("manager");
    var ApplicationsOfUserCache = Packages.org.wso2.carbon.appfactory.core.cache.ApplicationsOfUserCache;
    var MultiTenantUtils = Packages.org.wso2.carbon.utils.multitenancy.MultitenantUtils;


    var VersionComparator = function(a, b)
    {
        return b.version.localeCompare(a.version);
    };


    var loadConfigValueFromCarbon = function(configElem)
    {
    	return server.osgiService('org.wso2.carbon.base.api.ServerConfigurationService').getFirstProperty(configElem);
    };
    
    // In index.jag page this method is called before rendering. via getAllAppsOfUser()
    // So untill we fix it from there dont remove start tenantflow here.
    var getAllApps = function(userName){
                var appsOfUser;
                var tenantDomain=modManager.getTenantDomain() ;
                var context=multitenancy.getPrivilegedCarbonContext();
                var tenantManager= multitenancy.getTenantManager();
                try{
                    context.startTenantFlow();
                    context.getThreadLocalCarbonContext().setTenantId(tenantManager.getTenantId(tenantDomain));
                    context.getThreadLocalCarbonContext().setTenantDomain(tenantDomain);
                    var service = server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationInfoService') ;
                    appsOfUser = service.getApplicationInfoForUser(userName);
                } catch (e) {
                    log.error("Error while getting list of all applications of the user : " + userName + " of tenant "
                              + "domain : " + tenantDomain);
                    log.error(e);
                    throw e;
                } finally {
                    context.endTenantFlow();
                }
        return appsOfUser;
    };

/**
 *
 * @param userName user name eg:user@tenant.com
 * @returns {*} an array of applications.
 */
    var getApplicationsCreatedByUser = function (userName) {
        var appsCreatedByUser;
        var tenantDomain = modManager.getTenantDomain();
        try {
            var service = server
                    .osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationInfoService');
            appsCreatedByUser = service.getApplicationsCreatedByUser(userName);
        } catch (e) {
            log.error("Error while getting all applications created by user : " + userName + " of tenant domain : "
                      + tenantDomain);
            log.error(e);
            throw e;
        }
        return appsCreatedByUser;
    };

    var getRepoURL = function(applicationKey, version, auth, isForked)
    {

        if (auth) {
            jagg.module("permission").checkUserActionPermission(applicationKey, PERMISSION_APPLICATION_MEMBER);
        }
        
        var url;
        var tenantDomain=modManager.getTenantDomain() ;
        try{
            url = server.osgiService('org.wso2.carbon.appfactory.repository.mgt.service.RepositoryManagementService').
                    getURLForAppVersion(applicationKey, version, jagg.getUser().split('@')[0], isForked);

        } catch (e) {
            log.error("Error while getting RepoURL for the application : " + applicationKey + " with version : "
                      + version + " of tenant domain : " + tenantDomain);
            log.error(e);
            throw e;
        }
        return url;
    };

    var getAllAppsCountOfUser = function(userName)
    {
         jagg.module("permission").checkUserAuthenticated();

         // this security check is needed in case of user trying to retrieve all apps of other users.
         if (userName != jagg.getUser()) {
             var message = jagg.getUser() + ' is trying to list applications of user:' + userName;
             log.error(message);
             throw message;
         }
         try {
             var result = getAllApps(userName);
             var ns = new Namespace("http://service.mgt.application.appfactory.carbon.wso2.org");
             var elements = result.ns::["return"].text();
             return elements.length();
         } catch (e) {
             log.error("Error while getting count of all applications of user : " + userName);
             log.error(e);
             throw e;
         }
    };

    var getAllAppsOfUser = function(userName){
        // jagg.module("permission").checkUserAuthenticated();
        var tenantDomain=modManager.getTenantDomain();
         try {
             var result;
             result = getAllApps(userName.split('@')[0]);
             var elementsArray = new Array();
             for (var applicationKey in
            result){
                 var appInfo = convertAppInfo(result[applicationKey]);
                 if (appInfo != null) {
                     elementsArray.push(appInfo);
                     modMananger.cacheTenantInfo(tenantDomain, appInfo.key , TENANT_INFO_APP_TYPE, appInfo.type);
                 }
             }
             return stringify(elementsArray);
         } catch (e) {
             log.error("Error while getting all application of user : " + userName + " of tenant domain : "
                       + tenantDomain);
             log.error(e);
             throw e;
         }
    };
    
    var getAppInfo = function (applicationKey) {
        var result;
        var tenantDomain=modManager.getTenantDomain();
        try {
            result = server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationInfoService')
                    .getApplication(applicationKey);
        } catch (e) {
            log.error(" Error while getting application info for the application : " + applicationKey
                      + " of tenant domain : " + tenantDomain);
            log.error(e);
            throw e;
        }
        if (result != null) {
            return convertAppInfo(result);
        }
        return null;
    };

    var convertAppInfo =  function(resourceContent){
        var application = extractAppInfo(resourceContent,false);
        application.users=modApplication.getUsersOfApplication(resourceContent.id);
        session.put("APP_INFO",application);
        return application;
    }

    /*This is a light weight method and it is used only in getUserHomeInfo*/
    var convertAppInfoLightWeight =  function(resourceContent){
        var application = extractAppInfo(resourceContent,true);
        return application;
    }

    var extractAppInfo=function(resourceContent,forUserHome){
        var application={};
        if(forUserHome){
            application.key = resourceContent.id;
            application.type = resourceContent.type;
        }else{
            application.key = resourceContent.id;
            application.owner = resourceContent.owner;
            application.type = resourceContent.type;
            application.language = modManager.getApplicationTypeBean(application.type).getProperty("Language");

            // custom url
            application.mappedSubDomain = resourceContent.mappedSubDomain;
            application.customUrl=resourceContent.customUrl;
            application.customUrlVerificationCode = resourceContent.customUrlVerificationCode;

            application.description = resourceContent.description;
            application.repositoryType = resourceContent.repositoryType;
            application.repositoryTypeDisplayName = getProperty("RepositoryProviderConfig." + application.repositoryType + ".Property.DisplayName");
            application.branchCount=resourceContent.branchCount;
        }

        application.typeDisplayName = modManager.getApplicationTypeBean(application.type).getDisplayName();
        application.isUploadable = modManager.getApplicationTypeBean(application.type).isUploadableAppType();	
	    application.name = resourceContent.name;
        application.repoAccessability = resourceContent.repoAccessability;

        //TODO
        application.inProduction = false;
        return application;
    };

    // This funciton get application rxt from registry and populate application object.
    // This is not secured as this is calling from getAllApp method. Any caller of this
    // function need to secure acess. Permission check is removed do reduce the tenant loading.
    /* var getAppInfoWithoutUserRoles = function(applicationKey)
    {
        var path = APPLICATIONS + applicationKey + APP_INFO;
        if (modResource.resourceExists(path)) {
            var resource = modResource.getResource(path);
            var resourceContent = resource.content;

            if (resourceContent. *::application. *::key.text() != undefined){
                var application = {};
                application.key = resourceContent. *::application. *::key.text();
                application.name = resourceContent. *::application. *::name.text();
                application.description = resourceContent. *::application. *::description.text();
                application.type = resourceContent. *::application. *::type.text();
                application.repositoryType = resourceContent. *::application. *::repository. *::type.text();
                return application;
            }
        }
        return null;
    }
    ;*/

    //checked
    var getAllAppVersionsInStage = function(stageName, userName)
    {
        var visibilityPermissionToStage = PERMISSION_VISIBILITY_STAGE + stageName;

        var allAppVersionArray = new Array();
        var applicationList = session.get("application_list");
        if(applicationList == null) {
            applicationList = mod.getAllAppsOfUser(jagg.getUser());
           session.put('application_list', applicationList);
        }
        var parsedArray = parse(applicationList);

        for (var i = 0; i < parsedArray.length; i++) {
            var application = parsedArray[i];
            var applicationKey = application.key;
            if (jagg.module("permission").isUserAccessGranted(applicationKey, visibilityPermissionToStage)) {
                var appVersions = getAppVersionsInStage(stageName, applicationKey, userName);
                if (appVersions != null) {
                    allAppVersionArray = allAppVersionArray.concat(appVersions);
                }
            }
        }

        return stringify(allAppVersionArray);
    };


    var getDeployedBuildId = function(applicationKey, version, stage){
    	return 1;
    };

    //Read the application build status
    var getLatestBuildSuccessInfo = function(applicationKey, version, stageName)
    {
        var applicatoinPath = APPLICATIONS + applicationKey;
        var path = applicatoinPath + "/" + stageName + "/" + version + "/appversion";
        var ret = {};
        ret.buildinfo = getLastBuildStatus(path);
        return ret;
    };

    var getAppVersionsInStage = function(stageName, applicationKey, userName, metaDataNeed, buildableforstage, isRoleBasedPermissionAllowed)
    {
        jagg.module("permission").checkUserActionPermission(applicationKey, PERMISSION_APPLICATION_MEMBER);
        if (isRoleBasedPermissionAllowed == "true") {
            var hasPermissiontToStage = jagg.module("permission").hasPermissionToStage(applicationKey, stageName);
            if (!hasPermissiontToStage) {
                return null;
            }
        }
        var artifacts;
        var tenantDomain=modManager.getTenantDomain() ;
        try{
            artifacts = server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationInfoService')
                    .getAllVersionsOfApplication(tenantDomain, applicationKey);
        } catch (e) {
            log.error("Error while getting application versions of : " + applicationKey + " in stage : " + stageName
                      + " of the tenant domain : " + tenantDomain);
            log.error(e);
            throw e;
        }
        var artifactsInStage = new Array();
        var artifactsInStageCount = 0;
        if (artifacts != undefined && artifacts.length > 0) {
            for(index in artifacts) {
                var element = artifacts[index];
                if(element['stage'] == stageName) {
                    artifactsInStage[artifactsInStageCount] = element;
                    artifactsInStageCount++;
                }
            }
        }
        var versions = getVersionInfo(applicationKey, artifactsInStage);
        if(versions !=null) {
            return stringify(versions);
        } else {
            return null;
        }
    }
    ;

    var getBranchInfo= function(applicationKey){
    	var result,tenantDomain=modManager.getTenantDomain();
    	try{
            result = server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationInfoService')
                    .getBasicApplicationInfo(applicationKey);
        } catch (e) {
            log.error(" Error while getting branch info for the application : " + applicationKey
                      + " of tenant domain : " + tenantDomain);
            log.error(e);
            throw e;
    	}
    	return result;
    }

   /*this mehtod return the information to populate the user home
   * of the user logged in user
   * */
    var getUserHomeInfo= function(){
        var userName=modManager.getDomainlessUserName();
    	var result,tenantDomain=modManager.getTenantDomain();
    	try{
            result = server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationInfoService')
                    .getApplicationSummaryForUser(userName);

    		 var elementsArray = new Array();
             for (var applicationKey in result){
                 var appInfo = convertAppInfoLightWeight(result[applicationKey]);
                 if (appInfo != null) {
                     elementsArray.push(appInfo);
                 }
             }
             return elementsArray;
         } catch (e) {
            log.error("Error while getting the user home info for the user : " + userName + " of tenant domain : "
                      + tenantDomain);
            log.error(e);
            throw e;
    	}
    	return result;
    }

    /**
     * Get deleted app keys of the tenantDomain from application context.
     *
     * @returns Array of deleted keys of the user's tenantDomain
     */
    var getDeletedAppKeysFromAppContext = function(){
        var allDeletedAppKeys = application.get(APP_CTX_DELETED_KEYS);
        var tenantDomain=modManager.getTenantDomain();
        var deletedAppKeysOfTenant = new Array();
        if(!isEmpty(allDeletedAppKeys) && allDeletedAppKeys[tenantDomain] &&
                             allDeletedAppKeys[tenantDomain].length > 0) {
            deletedAppKeysOfTenant = allDeletedAppKeys[tenantDomain];
        }
        return deletedAppKeysOfTenant;
    };


    /**
     * Get updated user user home information from cache.
     *
     * @returns  application info list as below
     * {
     *      "COMPLETED":{
     *              appKey1:{//app info},
     *              ...
     *          },
     *      "PENDING":{
     *              appKey5:{//app info},
     *              ...
     *          },
     *      "FAULTY":{
     *              appKey9:{//app info},
     *              ...
     *          },
     *  }
     */
    var getUpdatedUserHomeData = function(){
        updateUserHomeCacheWithDeletedApps();   // remove the deleted apps from the user home cache
        updateUserHomePendingApps();            // update the application creation status
        return getUserHomeDataFromCache();
    };

    /**
     * Get user home information from cache.
     * If the request is a cache miss, retrieve data from backend and return while caching
     * @returns  application info list as below
     * {
         *      "COMPLETED":{
         *              appKey1:{//app info},
         *              ...
         *          },
         *      "PENDING":{
         *              appKey5:{//app info},
         *              ...
         *          },
         *      "FAULTY":{
         *              appKey9:{//app info},
         *              ...
         *          },
         *  }
     */
    var getUserHomeDataFromCache = function(){
        var userHomeData = session.get(USER_HOME_CAHCE);
	var isApplicationsChanged = isApplicationsOfUserChanged();
        if(!userHomeData || isApplicationsChanged){
            userHomeData = getUserHomeInformation();
            session.put(USER_HOME_CAHCE,userHomeData);
        }
        return userHomeData;
    };

    /**
     * Add an application to user home cache.
     *
     * @param creationStatus application creation status
     * @param appKey application key
     * @param application application object
     */
    var addAppToUserHomeCache = function(creationStatus , appKey, application){
        var userHomeData = getUserHomeDataFromCache();
        userHomeData[creationStatus][appKey] = application;
        session.put(USER_HOME_CAHCE,userHomeData);
    };

    /**
     * Update the user home cache with deleted apps.
     * This method will get the deleted app keys form the application context and remove those apps from the user home
     * cache. We need this step since once an application is deleted, user home should be updated with the existing apps.
     */
    var updateUserHomeCacheWithDeletedApps = function() {
        var deletedKeys = getDeletedAppKeysFromAppContext();
        if(deletedKeys && deletedKeys.length > 0) {
            removeAppsFromUserHomeCache(APPLICATION_CREATION_STATUS.COMPLETED,deletedKeys);
            removeAppsFromUserHomeCache(APPLICATION_CREATION_STATUS.PENDING,deletedKeys);
            removeAppsFromUserHomeCache(APPLICATION_CREATION_STATUS.FAULTY,deletedKeys);
        }
    };

    /**
     * Remove application from user home cache.
     *
     * @param creationStatus current application creation status of the app.
     * @param appKeys application keys to be deleted as an Array
     */
    var removeAppsFromUserHomeCache = function(creationStatus , appKeys){
        var userHomeData = getUserHomeDataFromCache();
        for(var index in appKeys){
            delete userHomeData[creationStatus][appKeys[index]];
        }
        session.put(USER_HOME_CAHCE,userHomeData);
    };

    /**
     * Check and update the pending app status and move to corresponding list of the user home cache.
     */
    var updateUserHomePendingApps = function(){
        var appKeys = getAppKeysFromUserHomeCache(APPLICATION_CREATION_STATUS.PENDING);
        var userHomeData = getUserHomeDataFromCache();
        if(appKeys.length > 0){
            var updatedStatus = getAppCreationStatusByKeys(appKeys);
            if(!isEmpty(updatedStatus)) {
                for (var appKey in updatedStatus){
                    if(APPLICATION_CREATION_STATUS.PENDING != updatedStatus[appKey]) {
                        userHomeData = moveApplicationFromCreationStatus(userHomeData,APPLICATION_CREATION_STATUS.PENDING,
                                                                         updatedStatus[appKey],appKey);
                    }
                }
                session.put(USER_HOME_CAHCE,userHomeData);
            }
        }
    };

    /**
     * Get user home information from backend.
     *
     * @returns  application info list as below
     * {
     *      "COMPLETED":{
     *              appKey1:{//app info},
     *              ...
     *          },
     *      "PENDING":{
     *              appKey5:{//app info},
     *              ...
     *          },
     *      "FAULTY":{
     *              appKey9:{//app info},
     *              ...
     *          },
     *  }
     */
    var getUserHomeInformation= function(){
        var userName=modManager.getDomainlessUserName();
        var context=multitenancy.getPrivilegedCarbonContext();
        var service = getApplicationInfoService(context);
        try{
            var result=service.getApplicationSummaryForUser(userName);

            // init
            var appList = {};
            appList[APPLICATION_CREATION_STATUS.COMPLETED] ={};
            appList[APPLICATION_CREATION_STATUS.PENDING] ={};
            appList[APPLICATION_CREATION_STATUS.FAULTY] ={};

            for (var listKey in result){
                var appInfo = convertAppInfoLightWeight(result[listKey]);
                if (appInfo != null) {
                    var creationStatus = (appInfo.applicationCreationStatus) ? (appInfo.applicationCreationStatus) :
                                         APPLICATION_CREATION_STATUS.PENDING;
                    appList[creationStatus][appInfo.key] = appInfo;
                }
            }
            return appList;
        } catch (e) {
            log.error("Error while getting user home information for the  user : " + userName);
            log.error(e);
            throw e;
        }
        return result;
    };

    /**
     * Get application keys of application which has {@code creationStatus}.
     *
     * @param creationStatus  APPLICATION_CREATION_STATUS.*
     * @returns {Array} application keys
     */
    var getAppKeysFromUserHomeCache = function(creationStatus){
        var userHomeData = getUserHomeDataFromCache();
        var appKeys = new Array();
        var statusAppList = userHomeData[creationStatus];
        for (var appKey in statusAppList){
            appKeys.push(appKey);
        }
        return appKeys;
    };

    /**
     * Convert given {@code hashMap} to js object
     *
     * @param hashMap HashMap to be converted
     * @param valuesAsStrings whether to convert values to string or not.
     * @returns js Object with key value pairs
     *  e.g {
     *          appkey1:COMPLETED,
     *          appKey2:PENDING
     *      }
     */
    var convertHashMapToJsObject =function(hashMap,valuesAsStrings){
        var jsObject = {};
        if(hashMap && hashMap.entrySet() && hashMap.entrySet().toArray()) {
            var entitySetArray = hashMap.entrySet().toArray();
            for(var index in entitySetArray){
                var entity=entitySetArray[index];
                if(valuesAsStrings == true){
                    jsObject[entity.getKey()] = entity.getValue().toString();
                } else {
                    jsObject[entity.getKey()] = entity.getValue()
                }
            }
        }
        return jsObject;
    };

    /**
     * Get application creation status by application keys.
     * @param  applicationKeys array of application keys
     *
     * @returns js Object with appkey-status as key value pairs
     *  e.g {
     *          appkey1:COMPLETED,
     *          appKey2:PENDING
     *      }
     */
    var getAppCreationStatusByKeys = function(applicationKeys){
        var context=multitenancy.getPrivilegedCarbonContext();
        var service = getApplicationInfoService(context);
        try{
            var resultHashMap = service.getAppCreationStatus(applicationKeys);
            return convertHashMapToJsObject(resultHashMap,true);
        } catch (e) {
            log.error("Error while retrieving app creation status for app keys : " + applicationKeys);
            log.error(e);
            throw e;
        }
    };

    /**
     * Get ApplicationInfoService osgi service.
     *
     * @param context Privileged Carbon Context
     * @returns service reference
     */
    var getApplicationInfoService = function(context){
        var tenantDomain=null;
        try{
            tenantDomain=modManager.getTenantDomain() ;
            return server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationInfoService');
        } catch(e) {
            log.error("Error while getting ApplicationInfoService for the tenant : " + tenantDomain);
            log.error(e);
            throw e;
        }
    };

    /**
     * Moves application represented by {@code appKey} from {@code currentStatus} to {@code newStatus}.
     *
     * @param appList user home data object
     * @param currentStatus current status of the app
     * @param newStatus new status of the app
     * @param appKey application key.
     * @returns {*} updated user home object
     */
    var moveApplicationFromCreationStatus = function(appList, currentStatus , newStatus, appKey){
        if(!isEmpty(appList) && !isEmpty(appList[currentStatus]) && !isEmpty(appList[currentStatus][appKey])) {
            if(isEmpty(appList[newStatus])){
                appList[newStatus] = {};
            }
            appList[newStatus][appKey] = appList[currentStatus][appKey];
            appList[newStatus][appKey][FIELD_APP_CREATION_STATUS] = newStatus;
            delete appList[currentStatus][appKey];
        }
        return appList;
    };

    /**
     * Check whether the {@code obj} is empty object({}) or not.
     *
     * @param obj
     * @returns {boolean}
     */
    var isEmpty = function(obj){
        if(!obj){       // if object is null
            return true;
        } else {
            return (Object.getOwnPropertyNames(obj).length === 0);
        }
    };

    var getApplicationInfoService = function () {
        var carbon = require('carbon');
        var service;
        var tenantDomain=modManager.getTenantDomain() ;
        try{
            service = carbon.server
                    .osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationInfoService');
        } catch (e) {
            log.error("Error while getting application info service for the tenant domain : " + tenantDomain);
            log.error(e);
            throw e;
        }
        return service;
    }


   var getMetaDataForApplicationState = function(applicationKey, version, stage, state, type)
    {
        jagg.module("permission").checkUserActionPermission(applicationKey, PERMISSION_APPLICATION_MEMBER);


        var tenantDomain = modManager.getTenantDomain();
        var loggedInUser = jagg.getUser();
        var userName = "";
        if (loggedInUser != null) {
            userName = loggedInUser.split("@")[0];
        }
        var status;
        var url;
        var accessUrl;

        try {
            accessUrl = server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationInfoService')
                    .getApplicationUrl(applicationKey, version, stage, tenantDomain);
            status = server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationInfoService')
                    .getApplicationStatus(applicationKey, version, stage);
            if(!status){
                 //fix for APPFAC-2195
                 //load the tenant
                 if(accessUrl){
                   var xhr = new XMLHttpRequest();
                   xhr.open("GET",accessUrl + "",false);
                   xhr.send("");
                   }
                status = server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationInfoService')
                        .getApplicationStatus(applicationKey, version, stage);
            }
            if(status){
               url=accessUrl;
             }

        } catch (e) {
            log.error(" Error while getting metadata for application state  for the application : " + applicationKey
                      + " with version : " + version + " in stage : " + stage);
            log.error(e);
            throw e;
        }

        var data = {};
        data.url = url;
        data.status = status;
        data.type = type;

        return data;
    };
   

    var listAppsWithDetails = function()
    {
        // not secured as getAppInfo method is secured.
        var applicationKeyArray = jagg.require(jagg.getModulesDir() + "dashboard/get/list.jag").getAllApplications.apply(this, arguments);
        var applicationsArray = new Array();
        for (var _index = 0; _index < applicationKeyArray.length; _index++) {
            var _application = getAppInfo(applicationKeyArray[_index]);
            applicationsArray[_index] = _application;
        }
        return applicationsArray;
    }
    ;

//chekced
    var getAllStages = function()
    {
        jagg.module("permission").checkUserAuthenticated();
        var stages = getProperties(DEPLOYMENT_STAGES);
        if (stages == null) {
            return null;
        }

        var stageArray = new Array();

        var counter = 0;
        while (stages[counter] != null) {
            stageArray[counter] = stages[counter];
            counter++;
        }

        return stringify(stageArray);
    }
    ;

//chekced
    var getBuildableStages = function()
    {
        jagg.module("permission").checkUserAuthenticated();
        var stages = getProperties(DEPLOYMENT_STAGES);
        if (stages == null) {
            return null;
        }

        var stageArray = new Array();

        var counter = 0;
        try {
            while (stages[counter] != null) {
                if (getProperty('ApplicationDeployment.DeploymentStage.' + stages[counter] + '.Buildable') == "true") {
                    stageArray[stageArray.length] = stages[counter];
                }
                counter++;
            }
        } catch (e) {
            log.error("Error while getting Buildable stages from appfactory.xml");
            log.error(e);
            throw e;
        }

        return stringify(stageArray);
    }
    ;

//chekced
    var getAllAppVersionsInStages = function(userName)
    {
        jagg.module("permission").checkUserAuthenticated();
        var allAppVersionArray = new Array();
        var applicationList = session.get("application_list");
        if(applicationList == null) {
            applicationList = mod.getAllAppsOfUser(userName);
            session.put('application_list', applicationList);
        }
        var allStages = getAllStages();
        var parsedStages = parse(allStages);
        var parsedArray = parse(applicationList);

        for (var i = 0; i < parsedArray.length; i++) {
            var application = parsedArray[i];

            for (var j = 0; j < parsedStages.length; j++) {
                var stage = parsedStages[j];
                var hasPermissiontToStage = jagg.module("permission").hasPermissionToStage(application.key, stage);
                if (!hasPermissiontToStage) {
                    continue;
                }
                var appVersions = getAppVersionsInStage(stage, application.key, userName);
                if (appVersions != null) {
                    allAppVersionArray = allAppVersionArray.concat(appVersions);
                }
            }
        }

        return stringify(allAppVersionArray);
    }
    ;

    var getRetiredVersions = function(applicationKey, userName)
    {
        jagg.module("permission").checkUserActionPermission(applicationKey, PERMISSION_APPLICATION_MEMBER);
        var versionsArray = new Array();
        var retiredApp = getAppVersionsInStage("Retired", applicationKey, userName, false, false, false);
        if (retiredApp != null) {
            retiredApp = parse(retiredApp);
            if (retiredApp.length > 0) {
                var application = retiredApp[0];
                var versions = application.versions;
                for (var j = 0; j < versions.length; j++) {
                    var versionInfo = versions[j];
                    versionsArray.push(versionInfo.version);
                }
            }
        }
        return versionsArray;
    }
    ;

    var getAppVersionInfoByVersion = function(applicationKey, version, userName)
    {
      
        var artifacts;
        var tenantDomain=modManager.getTenantDomain() ;
        try {
            artifacts = server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationInfoService')
                    .getAllVersionsOfApplication(tenantDomain, applicationKey);
        } catch (e) {
            log.error("Error while getting application version info by version for the applicatin : " + applicationKey
                      + " with version : " + version + " of tenant domain : " + tenantDomain);
            log.error(e);
            throw e;
        }

        var artifactsInStage=[];

	    for(index in artifacts) {
		var element = artifacts[index];
			if(element['version'] == version) {
			    artifactsInStage.push(element);
	            break;
			}
	    }
        
        var versions = getVersionInfo(applicationKey, artifactsInStage);
        return versions;
       
    };   
    
    var getAppVersionsInStages = function(applicationKey, userName, metaDataNeed, buildableforstage, isRoleBasedPermissionAllowed)
    {
        jagg.module("permission").checkUserActionPermission(applicationKey, PERMISSION_APPLICATION_MEMBER);
        var applicatoinPath = APPLICATIONS + applicationKey;
        var artifacts;
        var tenantDomain=modManager.getTenantDomain() ;
        try {
            artifacts = server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationInfoService')
                    .getAllVersionsOfApplication(modManager.getTenantDomain(), applicationKey);
        } catch (e) {
            log.error("Error while getting app versions in stages for the application : " + applicationKey
                      + " of tenant domain : " + tenantDomain);
            log.error(e);
            throw e;
        }
	    var versions = getVersionInfo(applicationKey, artifacts);
        if(versions !=null) {
            return stringify(versions);
        } else {
            return null;
        }
    };

var getStage = function(applicationKey, version) {
    jagg.module("permission").checkUserAuthenticated();
    var tenantDomain = modManager.getTenantDomain();
    try {
        return getApplicationInfoService().getStage(applicationKey, version);
    } catch (e) {
        log.error("Error while getting stage of application :  " + applicationKey + " with version : " + version
                  + " of the tenant domain : " + tenantDomain);
        log.error(e);
        throw e;
    }
};

var getVersionInfo = function(applicationKey, artifacts) {
        //send the call to the backend
        if (artifacts != undefined && artifacts.length > 0) {
            var appVersions = new Array();
            var applicationInfo = getAppInfo(applicationKey);
            if (applicationInfo != null && applicationInfo != undefined) {
                var arrVersions = new Array();
                var k = 0;
                for (var i = 0; i < artifacts.length ; i++) {
                    var versionInfo = {};
                    var element =artifacts[i];
                    versionInfo.version = element['version'];
                    versionInfo.autoDeployment = "true";
                    versionInfo.stage = element['stage'];
                    versionInfo.isAutoBuild = element['autoBuild'] ? "true" : "false" ;
                    versionInfo.isAutoDeploy = element['autoDeploy'] ? "true" : "false";
                    versionInfo.repoURL = getRepoURL(applicationKey, versionInfo.version, true, false);
                    versionInfo.lastBuildResult =element['lastBuildStatus']!=null ? element['lastBuildStatus'] : '';
                    versionInfo.currentBuildStatus =element['currentBuildStatus'];
                    versionInfo.promoteStatus =element['promoteStatus'];
                    
                    versionInfo.deployedBuildId = element['lastDeployedId'];
                    versionInfo.productionMappedDomain = element['productionMappedDomain'];
                    
                    versionInfo.isInitialStage = modLifecycle.isInitialLifeCycleStage(versionInfo.stage);
                    
                    arrVersions[k] = versionInfo;
                    k = k + 1;
                }

                arrVersions.sort(VersionComparator);

                //////applicationInfo.stage = stageName + '';
                applicationInfo.versions = arrVersions;
                appVersions[0] = applicationInfo;
            }
	        return appVersions;
        }
        return null;
};

var getRepoUserInfo = function(applicationKey, artifacts) {
        //send the call to the backend
        if (artifacts != undefined && artifacts.length > 0) {
            var appVersions = new Array();
            var applicationInfo = getAppInfo(applicationKey);
            if (applicationInfo != null && applicationInfo != undefined) {
                var arrVersions = new Array();
                var k = 0;
                for (var i = 0; i < artifacts.length ; i++) {
                    var versionInfo = {};
                    var element =artifacts[i];
                    versionInfo.version = element['version'];
                    versionInfo.autoDeployment = "true";

		            versionInfo.stage = element['stage'];
                    versionInfo.isAutoBuild = element['autoBuild'] ? "true" : "false" ;
                    versionInfo.isAutoDeploy = element['autoDeploy'] ? "true" : "false";
                    versionInfo.repoURL = element['repoURL'];
                    versionInfo.lastBuildResult =element['lastBuildStatus']!=null ? element['lastBuildStatus'] : '';
                    versionInfo.currentBuildStatus =element['currentBuildStatus'];
                    versionInfo.promoteStatus =element['promoteStatus'];
                    versionInfo.deployedBuildId = element['lastDeployedId'];
                    arrVersions[k] = versionInfo;
                    k = k + 1;
                }

                arrVersions.sort(VersionComparator);

                //////applicationInfo.stage = stageName + '';
                applicationInfo.versions = arrVersions;
                appVersions[0] = applicationInfo;
            }
	        return appVersions;
        }
        return null;
};

    var getAppCountInStage = function(applicationKey, userName)
    {
        // no need to secure as internal call is secured.
        var versionArray = new Array();
        var allStages = getAllStages();

        for (var i = 0; i < allStages.length; i++) {
            var stageName = allStages[i];
            var versionEntry = {};
            versionEntry.stage = stageName;
            var applicationList = getAllAppVersionsInStage(stageName, applicationKey, userName);

            if (applicationList == null) {
                continue;
            }

            var versionCount = 0;
            for (var j = 0; j < applicationList.length; j++) {
                var applicationInfo = applicationList[j];

                if (applicationInfo == undefined) {
                    continue;
                }
                versionCount += applicationInfo.versions.length;
            }

            versionEntry.count = versionCount;
            versionArray[i] = versionEntry;
        }
        return versionArray;
    };
    
  //application icon resource read from registry
    var loadAppIcon = function (applicationKey) {
        var tenantDomain = modManager.getTenantDomain();
    	 try{
    	  	var serverUrl = getProperty(APPFACTORY_SERVER_URL);
    	  	var carbon = require('carbon');
    	  	var registryOsgi = new carbon.registry.Registry(serverUrl, {
    	  	   username: getProperty(ADMIN_USERNAME),
    	  	   password: getProperty(ADMIN_PASSWORD)
    	  	});
    	  	var path = "/_system/governance/repository/appicon/icon_"+ applicationKey ;
    	  	var res = registryOsgi.get(path);
    	  	return res;
      	
    	  } catch (e) {
             log.error("Error  while loading the icon for application : " + applicationKey + " of tenant : "
                       + tenantDomain);
             log.error(e);
             throw e;
    	  }
    };

    var getAppVersionsOfUser = function(applicationKey, userName, metaDataNeed, buildableforstage, isRoleBasedPermissionAllowed)
    {
        jagg.module("permission").checkUserActionPermission(applicationKey, PERMISSION_APPLICATION_MEMBER);
        var artifacts;
        var tenantDomain=modManager.getTenantDomain() ;
        try {
            artifacts = server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationInfoService')
                    .getAllVersionsOfApplicationPerUser(modManager.getTenantDomain(), applicationKey, userName);
        } catch (e) {
            log.error("Error while getting application versions of application : " + applicationKey + " for the user : "
                      + userName + " of tenant domain : " + tenantDomain);
            log.error(e);
            throw e;
        }
	    var versions = getRepoUserInfo(applicationKey, artifacts);
        if(versions !=null) {
            return stringify(versions);
        } else {
            return null;
        }
    };
     var getBuildandDelpoyedStatus= function(applicationKey,version){
          var buildAndDeployInfo;;
          var result ={};
      	  var tenantDomain=modManager.getTenantDomain() ;
      	  try{
              buildAndDeployInfo = server
                      .osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationInfoService')
                      .getBuildandDelpoyedStatus(applicationKey, tenantDomain, version);
                 if(buildAndDeployInfo!=null){
                 	result.buildId=buildAndDeployInfo['lastBuildId'];
                 	result.buildStatus=buildAndDeployInfo['lastBuildStatus'];
                 	result.deployedId=buildAndDeployInfo['lastDeployedId'];
                 }
          }catch (e){
              log.error(" Error while getting build and deployed status for application : " + applicationKey
                        + " with version : " + version);
              log.error(e);
              throw e;
      	   }
          
      	  if(result !=null) {
      	      return stringify(result);
      	  } else {
      	      return null;
      	  }
      	
      
    };

    var isApplicationsOfUserChanged = function(){
       var tenantDomain=modManager.getTenantDomain() ;
       var context=multitenancy.getPrivilegedCarbonContext();
       var tenantManager= multitenancy.getTenantManager();

       try{
           context.startTenantFlow();
           context.getThreadLocalCarbonContext().setTenantDomain(tenantDomain, true);
           var isApplicationsOfUserChanged = ApplicationsOfUserCache.getApplicationsOfUserCache().isUserInvitedToApplication(MultitenantUtils.getTenantAwareUsername(jagg.getUser()));
       }catch (e){
           var errMsg = "Error  while checking user : " + jagg.getUser() + " added to an application \n" ;
           log.debug( errMsg );
       }finally{
           context.endTenantFlow();
       }
       return isApplicationsOfUserChanged;
    }
%>
